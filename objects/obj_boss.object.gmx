<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_boss1_1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-6</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 0.5;

//General variables
wait = 0;
moveSpeed = 0;
currentHSpeed = moveSpeed;
stopMoving = false;
aggroZone = 250;
damage = 10;
hp = 20; //Hp on phase 1
phase = 2;
recoveryFrames = 30;//Recovery time when being hited phase 1 &amp; 2
recovery = 0;
invulnerabilityFrames = 35;//Invulnerability time on patterns phase 3
invulnerability = 0;
invulnerable = false;
transition = false;
pattern = 0;

//Phase 1 states
strike = false;
walk = true;

//Phase 2 states
phase2hp = 100;
fly = false;
flyOut = false;
launch = true;
rotate = false;
attack = false;
yMaxLimit = 280;
yMinLimit = 270;
xMinLimit = view_xview + 200;
xMaxLimit = view_wview - 200;
currentVSpeed = 0;
rotationSpeed = 0;
currentRotation = 0;
rotationDir = -1;
nextAttack = 1;
stopPattern = 25;
flyOutDir = 1;
goRight = true;


//Lighting variables
darkness = 200;
darknessMin = 150;
lightFade = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Lighting
if(obj_lighting.dark){
    Lighting(250, c_white, c_black);
}
if(transition) lightFade = true;
if(lightFade){
    if(phase == 2 || phase == 3){
        if(darkness &gt; darknessMin){
            darkness --;
            obj_lighting.color = make_color_rgb(darkness, darkness, darkness);
        }
        else {
            lightFade = false;
            darknessMin = 100;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Phase 1 : ol' weirdo walkin'
if(phase == 1){
    playerInAggroZone = obj_character.x &gt;= x - aggroZone &amp;&amp; obj_character.x &lt;= x + aggroZone;
    //When he's walking and the player is nearby
    if(playerInAggroZone &amp;&amp; walk){
        walk = false;
        strike = true;
        wait = -1;
    }
    
    //Striking pattern : walk a bit faster toward the player, attack him when close
    if(strike){
        //First time the player is in the aggro zone while a walk pattern
        if(wait == -1){
            image_xscale = behindPlayer();
            currentHSpeed = (moveSpeed - 2) * behindPlayer();
            wait = 60; //Don't run forever
        }
        //If the player is close : attack then wait
        if(distance_to_point(obj_character.x, obj_character.y) &lt; 40){
            currentHSpeed = 0;
            wait = 40;
        }
        
        if(wait &gt; 0){
            wait --;
        }
        else if(wait == 0){
            if (playerInAggroZone){ //If in the aggro zone : run again !
                wait = -1;
            }
            else { //If not, continue walking
                walk = true;
                currentHSpeed = moveSpeed;
            }
        }
    }
    //walking around the room
    if(walk){
        if(wait &gt; 0){//The boss will stay still or walk while wait is over 0
            wait--;
        }
        else{
            if(currentHSpeed != 0){//If already moving, stop moving
                currentHSpeed = 0;
                wait = irandom_range(10, 40);
            }
            else{//If not moving, start moving in a random direction on a random distance
                if(irandom_range(1, 2) == 1) dir = 1
                else dir = -1;
                currentHSpeed = moveSpeed * dir;
                image_xscale = dir;
                wait = irandom_range(10, 100); //Random distance range
            }
        }
    }
    
    if(hp &lt;= 0){
        walk = false;
        strike = false;
        transition = true;
        currentHSpeed = 0;
        sprite_index = spr_boss1_2;
        image_index = 0;
        image_speed = 0.2;
        hp = phase2hp;
        recovery = 0;
    }
    
    if(transition){
        if(image_index &gt;= sprite_get_number(spr_boss1_2) - image_speed){
            sprite_index = spr_boss1_3;
            image_speed = 0.3;     
            phase = 2;
            transition = false;
        }
    }
    
    if(place_meeting(x + hspeed, y, obj_ground01)){
        currentHSpeed *= -1;
        image_xscale *= -1;
    }
    hspeed = currentHSpeed;
}


 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Phase 2 : UFO
if(phase == 2){
    //Launching : smoothly fly to yMaxLimit and then stop
    if(launch &amp;&amp; wait == 0){
        invulnerable = true;
        yMaxLimit = 280;
        if(y &gt; yMaxLimit) currentVSpeed -=0.2;
        else{
            launch = false;
            fly = true;
            invulnerable = true;
            wait = 20;
            sprite_index = spr_boss_test2;
            rotationSpeed = 4;
            yMaxLimit += 10;
            yMinLimit = 270;
            xMinLimit = view_xview + 200;
            xMaxLimit = view_wview - 200;
            currentVSpeed = 0;
            currentHSpeed = 0;
            if(!instance_exists(obj_boss_rotate))
               instance_create(x, y, obj_boss_rotate);
        }
    }
    
    //Flying : go back and forth horizontally
    if(fly &amp;&amp; wait == 0){
        if(!flyOut){
            if(x &gt; xMaxLimit){
                if(currentHSpeed &gt; -15) currentHSpeed -= 1;
                flyOutDir = -1;
            }
            else if(x &lt; xMinLimit){
                if (currentHSpeed &lt; 15) currentHSpeed += 1;
                flyOutDir = 1;
            }
            if(y &gt; yMaxLimit){
                currentVSpeed -= 0.3;
            }
            else if(y &lt; yMinLimit){
                currentVSpeed += 0.3;
            }
            //Attack cooldown
            if(currentHSpeed == 0) nextAttack--;
        }
        else{//Fly Out : go out of the room
            if((x &gt; view_xview - 100 &amp;&amp; flyOutDir == -1)
            || (x &lt; view_wview + 100 &amp;&amp; flyOutDir == 1)){
                currentHSpeed *= 1.2;
                currentVSpeed *= 1.2;
            }
            else{ //Out of the room : pattern instanciation
                fly = false;
                flyOut = false;        
                attack = true;
                if(pattern == 0){
                    currentHSpeed = -8 * flyOutDir;
                    currentVSpeed = -40;
                    yMaxLimit = 692;
                    yMinLimit = 640;
                    xMaxLimit = view_wview;
                    xMinLimit = view_xview;
                    y = yMaxLimit;
                    if(flyOutDir == -1) x = -10;
                    else x = view_wview + 10
                    image_angle = 90 * -(flyOutDir);
                    rotationSpeed = 0;
                    stopPattern = 25;
                    
                }
                else if(pattern == 1){
                    currentHSpeed = 0.3;
                    currentVSpeed = 0;
                    y = irandom_range(600, 726);
                    xMaxLimit = view_wview + 70;
                    xMinLimit = view_xview - 70;
                    image_angle = 0;
                    stopPattern = 5;
                }
                else if(pattern == 2){
                    currentHSpeed = 10;
                    currentVSpeed = 10;
                    yMaxLimit = irandom_range(600, view_hview - 50);
                    yMinLimit = irandom_range(200, 400);
                    xMaxLimit = irandom_range(600, view_wview - 50);
                    xMaxLimit = irandom_range(view_xview + 50, 400);
                    image_angle = 0;
                    stopPattern = 5;
                }
            }
        }
    }
    else if(fly &amp;&amp; !rotate &amp;&amp; wait == 1){ //When it begin to fly
        rotate = true;
        currentHSpeed = 15;
        currentVSpeed = 1;
    }
    
    if(nextAttack == 0){//Attack instanciation
        nextAttack = 3;
        fly = false;
        pattern = 2;
        if(pattern == 0 || pattern == 1){
            flyOut = true;
            currentHSpeed = 0.5 * flyOutDir;
            currentVSpeed = 0.05;
        }
        if(pattern == 2){
                    attack = true;
                    currentHSpeed = -15;
                    currentVSpeed = +15;
                    yMinLimit = irandom_range(view_yview + 250, 350);
                    yMaxLimit = irandom_range(450, view_hview - 250);
                    xMinLimit = irandom_range(view_xview + 500, 540);
                    xMaxLimit = irandom_range(740, view_wview - 500);
                    y = yMinLimit;
                    x = xMinLimit;
                    //image_angle = 0;
                    stopPattern = 5;
                }
    }
    
    //Attack : do the random picked pattern
    if(attack){
        invulnerable = true;
        if(pattern == 0){ //Jump on the ground
            if(!flyOut){
                if(y &gt; yMaxLimit){
                    currentVSpeed = -40;
                    currentHSpeed = irandom_range(5 * sign(currentHSpeed), 15 * sign(currentHSpeed));
                    stopPattern --;
                }
                else if(y &lt; yMinLimit &amp;&amp; currentVSpeed &lt; 40){
                    currentVSpeed += 4;
                    rotationSpeed = 9;
                }
                else rotationSpeed = 0;
                
                //Go in the other way
                if(x &lt; xMinLimit &amp;&amp; (abs(image_angle) % 180) == 90){
                    rotationDir = -1;
                    currentHSpeed = 5;
                }
                else if(x &gt; xMaxLimit &amp;&amp; (abs(image_angle) % 180) == 90){
                    rotationDir = 1;
                    currentHSpeed = -5;
                }
                //launch an orb
                if(distance_to_object(obj_yellow) &gt; 400){
                    if(rotationDir == -1 &amp;&amp; abs(image_angle % 180) == 54){
                        orb = instance_create(x + 64, y + 12, obj_boss_orb);
                        
                    }
                    else if(rotationDir == 1 &amp;&amp; abs(image_angle % 180) == 135){
                        orb = instance_create(x - 64, y + 12, obj_boss_orb);
                    }
                }
            }
        }
        if(pattern == 1){ //Go back and forth horizontally and really fastly
            if(!flyOut){
                //Go in the other way
                if(x &lt; xMinLimit || x &gt; xMaxLimit){
                    y = irandom_range(600, 726);
                    //pattern --;
                }
                if(x &lt; xMinLimit){
                    currentHSpeed = 0.5;
                    x = xMinLimit + 1;
                }
                else if (x &gt; xMaxLimit){
                    currentHSpeed = -0.5;
                    x = xMaxLimit - 1;
                }
                else{//Throw bullets on player
                    instance_create(x, y, obj_boss_orb);
                }
                currentHSpeed *= 1.1;
            }
        }
        if(pattern == 2){
            if(x &lt; xMinLimit){
                currentHSpeed += 1;
                if(currentHSpeed == +15) xMinLimit = irandom_range(view_xview + 400, 440);
            }
            else if (x &gt; xMaxLimit) {
                currentHSpeed -= 1;
                if(currentHSpeed == -15) xMaxLimit = irandom_range(840, view_wview - 800);
            }
            if( y &lt; yMinLimit) {
                currentVSpeed += 1;
                if(currentVSpeed == 15) yMinLimit = irandom_range(view_yview + 250, 350);
            }
            else if (y &gt; yMaxLimit){
                currentVSpeed -= 1;
                if(currentVSpeed == -15) yMaxLimit = irandom_range(450, view_hview - 250);
            }
        }
        if(stopPattern == 0){
            wait = 20;
            launch = true;
            attack = false;
            currentVSpeed = 0;
            currentHSpeed = 0;
            rotate = false;
        }
    }

    
    //Rotate : rotate the sprite
    if(rotate){
        image_angle += rotationSpeed * rotationDir;
    }
    
    if(wait &gt; 0) wait--;
    
    hspeed = currentHSpeed;
    vspeed = currentVSpeed;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Hitting and being hitted
if(!transition){
    if(recovery == 0 &amp;&amp; !invulnerable){
        touchWeapon = collision_rectangle(obj_character.x + (36 * obj_character.image_xscale),
                                          obj_character.y,
                                          obj_character.x + (78 * obj_character.image_xscale),
                                          obj_character.y + 20,
                                          id, true, false);
        if(touchWeapon &amp;&amp; obj_character.strike){
            hp -= 10;
            recovery = recoveryFrames;
        }
        if(phase == 2){
            if(place_meeting(x, y, obj_bullet)){
                with(obj_bullet) instance_destroy();
                hp -= 10;
                recovery = recoveryFrames;
            }
        }
    }
    else if(recovery &gt; 0){
        if(phase == 1){//Flicker on first phase
            if(recovery % 6 &gt;= 3 &amp;&amp; recovery % 6 &lt;= 6) image_alpha = 0; 
            else image_alpha = 1;
        }
        else if (phase == 2){//Rotate faster on second phase
            rotationSpeed = 40;
            rotationDir = 1;
            if(recovery == 1){
                rotationSpeed = 4;
                rotationDir = -1;
            }
        }
        recovery --;
    }
    
    if(place_meeting(x, y, obj_character) &amp;&amp; !obj_character.strike
        || place_meeting(x, y, obj_yellow)){
        obj_character.hit = true;
        obj_character.ennemy = id;
        obj_character.damage = damage;
        obj_character.enemyBehind = behindPlayer();
    }       
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
